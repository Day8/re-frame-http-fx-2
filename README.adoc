:source-highlighter: coderay
:source-language: clojure
:toc:
:toc-placement: preamble
:sectlinks:
:sectanchors:
:toc:
:icons: font

> This library is under development. You shouldn't use it, yet.

image:https://circleci.com/gh/Day8/re-frame-http-fx-2.svg?style=svg["CircleCI", link="https://circleci.com/gh/Day8/re-frame-http-fx-2"]


== Easy and Robust HTTP Requests

A re-frame library for performing HTTP requests using an effect with key `:http`

== Overview

HTTP requests are simple, right?

You send off a request, you get back a response and you store it in `app-db`. Done.

Except, of course, _**requests are anything but simple**_.  There is a happy path, yes, but it winds through a deceptively dense briar thicket of fiddly issues. Coding for unreliable servers and unreliable networks using an async flow of control is hard enough by itself, what with the multiple failure paths and possible retries but, on top of that, there's also the *_cross-cutting issues_* of managing UI updates, user-initiated cancellations, error recovery, logging, statistics gathering, etc. Yeah, there's a bit going on.

Many programmers instinctively shy away from the tentacles of this complexity, pragmatically preferring naive but simple solutions. And yet, even accepting that tradeoff, they can find themselves with an uncomfortable amount of repetition and boilerplate.

This library has two goals:

  1. proper treatment for failure paths (robustness and a better user experience)
  2. you write less code for each request (no repetition or fragile boilerplate)

These two goals would normally pull in opposite directions but this library liberates you from the horns of this dilemma, and seeks to let you have your cake and eat it too. In fact, maybe even eat it twice.  But no chocolate sprinkles - we're not monsters.

== An Indicative Code Fragment 

Here's a re-frame event handler returning an effect keyed `:http`. 

[source, Clojure]
----
(ref-event-fx 
  :switch-to-articles-panel
  (fn [{:keys [db]} _]
    ;; Note the following :http effect
    {:http {:http/get  "http://api.something.com/articles/"
            :http/path [:put :response :data :at :this :path :in :app-db]}}))
----


That `:http` effect will initiate a GET to the URL nominated and it will put the response data into `app-db` at the path nominated. The request will be retried on timeouts, and 503 failure, etc. It will log, it will report errors and it can capture interesting statistics. It will also facilitate user-initiated cancellations and show the user a busy-twirly and it could process the response data from transit to EDN before, then, placing it at the right spots within `app-db`.

So with two lines of code - simple ones at that - you'll get a good robust HTTP request process. And you'll soon see that there's no  magic happening to achieve the outcome. You just need to *_compose the right defaults_*.

If there is a cost - and there is *_always_* a cost for abstraction - it is that you'll need to do some upfront learning, and need to "code your defaults". Let's start that upfront learning process now ...

== An Overview

I have some good news and some bad news. Good news first.

This library models an HTTP request using a Finite State Machine (hereafter FSM) - one which captures the various failure paths and retry paths, etc. And that leads to a robust and understandable request process. 

Also, this library wraps `fetch`, making it central to the FSM, and that means the network-level mechanics of a request are supplied in a browser-modern way.

That's the end of the good news which is itself the bad news - because you need to do the rest of the work.

This library leaves parts of the FSM unimplemented and it asks that you fill in these blanks by writing a number of *_Logical State handlers_*. 

Each `Logical State handler` provides the behaviour for a single *_Logical State_* in the FSM.  To help you, this library provides  "a task recipe" for each handler, describing what your implementation is expected to do. So, for example, in the `Failed` state, the recipe might say that you "perform error reporting" and "recover the application into a stable state, in light of the failure".

Of course, there's a myriad of ways to implement both of these tasks and only you, the application programmer, know how to make it happen correctly for your application.  And that's exactly why the FSM is left incomplete and why you are asked to fill in the blanks.

NOTE: With a bit of squinting and head tilting, you can see a *_Logical State Handler_* as something of a *_callback_*. For example, writing a `Logical State Handler` for the `Failed State` is very similar to supplying an `on-failure` callback. As we'll soon see, there is slightly more going on, but that's a pretty good first approximation. And, of course, because we're in re-frame land, the mechanism will be more `dispatch-back` than `callback`.

Each `Logical State handler` you write has to do the right thing (follow the task recipe), and be something of a "good citizen" within the overall composition. If your `Logical State handler` fails to do the right thing, any FSM you compose using it will be, to some extent, dysfunctional. I have every confidence in you.

Later, once you have written the necessary set of `Logical State handlers`, you *_compose them to form a functioning FSM_*. And, because this is a ClojureScript library, this composition happens in a *_data oriented_* way. 

If your application's needs are sufficiently complicated, you can create multiple FSM compositions within the one app, with each configuration designed for a different kind of request. 

And, if one of them is used more regularly, you can nominate it to be *_the default FSM_*. That two line example shown earlier owes its brevity to (implicitly) using a `default` FSM composition. 

Finally, to round off this overview, we note that each FSM instance has some working state, which we call `request-state`. In addition, there will likely be some state in `app-db` which is also associated with a request. Your `Logical State handlers` will
be responsible for pushing/projecting parts of `request-state` through into `app-db`, so that your UI can reflect the state of the request. Again, only you, the application programmer, know how you want this done, although we will certainly be suggesting some useful patterns. For example, you might write a `:retrying?` value of `true` into `app-db` which then causes the UI to render "Sorry about the delay. There was a problem with the network connection, so we're trying again".

So, here's the plan: 

* you should get to know the FSM topology it proposes (next section)
* you will implement the blank parts of the FSM but writing a set of `Logical State handlers`, following the recipe for each.
* you will compose an ensemble of these `Logical State handlers` to form a FSM
* your FSM will maintain/manage `request-state`
* your FSM will likely push/project aspects of `request-state` into `app-db` 
* you will write views in terms of what's projected into `app-db`, showing the user what's happening 
* and when the time comes, when you actually make the HTTP request, you'll be nominating which FSM to use (or you will implicitly be using your default FSM)


== The FSM

An HTTP request is a multistep process which plays out over time. 

We formalise it as a *_a machine_*, and specifically a Finite State Machine (FSM). The Internet is full of excellent resources describing FSMs, so here I'll be brief. 

By *_a machine_*, I'm referring to the abstract concept of something which *_does something_*. 

With a FSM the *_machine_* has a set of *_Logical States_* and *_Transitions_* defined between them.  *_Logical States_* are a way to reason about *_where_* a machine is within an overall process. Each Logical State has discrete responsibilities, concerns and behaviours. 

*_Transitions_* cause a FSM to move from one Logical State to another - from one behaviour to another. Over time - and I really would like to stress this time bit - events occur which trigger Transitions. That means a FSM goes from doing one thing, to doing another thing.

The `Logical State handlers` you write are about "doing a thing". They implement behaviour for one part of "the machine". 

The FSM at the core of this library is as follows: 

image::http://www.plantuml.com/plantuml/png/ZLDFJznE3BtFfx3WykEdheHwGLgj4B0Lwg47H0yz40vEnikEDh5JZrEqglhTEzc4T3OKrBazvptx-K-keg5QrzJEf0KJACLC6l11gR8W36uRF04rhUt1Kwmqj7tSkRWBtA9Y0t6BNfu3Fy46wqZPbnAhtPDAntujjIYStgQNAmsDuAS3W1jHJphIhg-lK-orVBrU7xZ7yTKAFcFRxk_GjfUNy2KyRUscxcYMTaQxbptM1zelvzpWvEIUldSKZVm904QO8AItMcNo5y4t39OwJ_I3O8G0RmhkL2gAyQ19WZ_mBS7Nhgg8_8kb2RvPuPCmzNv6IpqSqLpWN5P-2OOx0jiIACLME1AKulSV2cu75aK81iWUsXehIg3Wm90IBdpfijQNi14512Px5jr19Sp3EHNSon4YwG_IgL3lewof6SJ9ryF_Zp2-nSFfjAh7nMM-aoNe09pBedF1aR58R3FonSL5JnlUBOOwnGTou4fKa_E2fqAPqxbsvinqdx7VhxH9eE2IAkmYWOb0Wxplove6YY0Af2eA8HRSfN0bQNwOShjyyFCQHsErq91qzi_yZcD_Qp5kkkJjlxyjKtJSvE3kBCyzNyFHgOsPKrg4Z-Vdqo6SlUTkZLnHNG_pnLBKahw_rowIWf4sWT785zm7nusTEO3ipDzVGpln2ZvqD5Fc3UL_ugGaxrmMdqkoVt49FW6NbL_uOskloTa0vcsy9hiiDFUHVYztHUoxfluD[FSM,600]


Notes:

* to use this library, you'll need to understand this FSM
* the boxes in the diagram represent the FSM's _*Logical States_*
* the lines between the boxes are the *_Transitions_*
* when you write a `Logical State Handler` you are implementing the behaviour for one of the boxes
* the "happy path" is shown in blue  (both boxes and lines)
* and, yes, there are variations on this FSM model of a request - this one is ours. We could, for example, have teased the "Problem" Logical State out into four distinct states: "Timed Out", "Connection Problem", "Recoverable Server Problem" and "Unrecoverable Server Problem".  We decided to NOT do that because of, well, reasons. My point is that there isn't a "right" model, just one that suits a purpose.


== Requesting

Earlier we saw this code: 

[source, Clojure]
----
(ref-event-fx 
  :switch-to-articles-panel
  (fn [{:keys [db]} _]
    ;; Note the following :http effect
    {:http {:http/get  "http://api.something.com/articles/"
            :http/path [:put :response :data :at :this :path :in :app-db]}}))
----

It uses an effect `:http` to initiate an HTTP GET request. 

That code was very terse. But now, to enhance your understanding of `:http`, let's pendulum to the opposite extreme and show you *_the most verbose_* use of the `:http` effect handler:  
[source, Clojure]
----
(reg-event-fx
  :request-articles
  (fn [_ _]
    {:http  {:http/get        "http://api.something.com/articles/"

             ;; Compose the FSM
             ;; Nominate the `Logical State handlers` to be used for this request.
             ;; Look back at the FSM diagram and at the boxes which represented 
             ;; Logical States. We are nominating what handler will implement the 
             ;; behaviour in each Logical State (each box of the diagram). 
             ;;
             ;; When the request transitions to a new Logical State, it will `dispatch`
             ;; the event you nominate below, and the associated event handler is expected
             ;; to perform "the behaviour" required in that Logical State.
             :http/in-process    [:my-processor]
             :http/in-problem    [:deep-think :where-did-I-go-wrong]
             :http/in-failed     [:call-mum]
             :http/in-cancelled  [:generic-cancelled]
             :http/in-succeeded  [:yah! "fist-pump" :twice]
             :http/in-done       [:so-tired-now]
             
             
             :http/params     {:user     "Fred"
                               :customer "big one"}
             :http/headers    {"Authorization"  "Bearer QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
                               "Cache-Control"  "no-cache"}

             ;; XXX describe this 
             :http/content-type {#"application/.*json" :json
                                 #"application/edn"    :text}


             ;; Optional, defaults to (keyword (gensym "http-")) e.g. :http-123
             ;; Useful when you want to 
             :http/id            :my-xyz-request ;; otherwise defaults to (keyword (gensym "http-")) e.g. http-123

             ;; Timeout
             ;; optional, by default request will run as long as browser implementation allows
             :http/timeout       5000 

             :http/credentials   "omit" ;; default is 'include'
             :http/redirect      "manual" ;; default is 'follow'
             :http/mode          "cors" ;; default is 'same-origin'
             :http/cache         "no-store" ;; default is 'default' ref https://developer.mozilla.org/en-US/docs/Web/API/Request/cache
             :http/referrer      "no-referrer" ;; default is 'client'
             
             ;; ref https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
             :http/integrity     "sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=" 

             ;; NOTE: GET or HEAD cannot have body!
             :http/body          String | js/ArrayBuffer | js/Blob | js/FormData | js/BufferSource | js/ReadableStream

             ;; Optional: the path within `app-db` to which request related data should be put
             ;; See section in these docs called `path state`  for more details 
             :http/path [:put :response :data :at :this :path :in :app-db]

             ;; Optional: an area to put application-specific data 
             ;; If data is supplied here, it will probably be used later within the 
             ;; implementation of a "state handler". For example "description"
             ;; might be a useful string for displaying to the users in the UI or
             ;; to put in errors or logs.
             :http/context {:max-retries  5
                            :description  "Loading articles"}}))
----

XXX add optional `:http/request-id`  and a  `:http/cancel` event

This specification offers a lot of flexibility. But we clearly don't 
want to repeat this much every time. Particularly because, time after time,
we'll likely want the same headers, or params and `Logical State handers`.

== Profiles

A *_profile_* is a fragment of an `:http` specification. It associates an 
id with a common, reusable piece of specification. 

You can "register" one or more *_profiles_* and you typically do this on application 
startup.

An `:http` specification is just data (a map) which means a fragment is also 
just data (again, a map). 
And if you think that sounds pretty simple, you'd be right.


== Registering A Profile

This code shows how to register a profile with id `:xyz`, and associate 
with it certain specification values:
[source, Clojure]
----
(reg-event-fx
   :register-my-http-profiles
   (fn [_ _]

      {:http   {;; Notice the use of `:http/reg-profile`
                ;; The value `:xyz` is the `id` of the profile being registered
                ;; The special value of `:http/default` says that this profile
                ;; should be used for all requests, unless otherwise overridden.
                ;; Clearly, you can register multiple profiles
                
                :http/reg-profile   :xyz
      
                ;; the values we are capturing and associating with this profile 
                :http/values {   
                              ;; compose the FSM
                              :http/in-process    [:my-processor]
                              :http/in-problem    [:generic-problem :extra "whatever"]
                              :http/in-failed     [:my-special-failed]
                              :http/in-cancelled  [:generic-cancelled]
                              :http/in-done       [:generic-done]
                              
                              :http/timeout       3000
                              
                              :http/context  {:max-retries 2}}
                                     
                ;; Optional, advanced feature.
                ;; Profiles themselves can be combined/composed.
                ;; In this section, you can specify how the `:http/values` in this 
                ;; profile should be combined with the values in other profile. 
                ;; For each key in `:http/values` provide you can provide a two argument 
                ;; function to do the combining. 
                ;; The two arguments given to this function will be:
                ;;    (1) the value in "other" profile 
                ;;    (2) the value in this profile
                ;; 
                ;; Example combining functions:
                ;;    - `merge` would be useful if combining maps
                ;;    - `conj` would be useful for combining vectors
                ;;    - `str` would be useful for combining strings (URI?)
                ;;    - `#(identity %2)` would cause the value in this profile
                ;;      overwrite the value in the other profile. 
                ;; 
                :http/combine   {:http/params   merge
                                 :http/get      str }}}))               
----

XXX Isaac are we using `default? true` approach 
XXX where do we talk about default. 

== Using A Profile

Here's an example of using that profile we registered above: 
[source, Clojure]
----
{:http {:http/get      "http://api.endpoint.com/articles/"
        :http/path     [:put :response :data :at :this :path :in :app-db]
        :http/profiles :xyz}}     ;;  <----- THIS IS THE NEW
----

That key `:http/profiles` allows you to nominate a previously registered `profile` `id`. The data 
specification (values) associated with that profile  `id` will be 
used in the request. 

Here's another example use, but this time with multiple profile ids (a `vector` of them):
[source, Clojure]
----
{:http {:http/get      "http://api.endpoint.com/articles/"
        :http/path     [:put :response :data :at :this :path :in :app-db]
        :http/profiles [:jwt-token :standard-parms :xyz]}}     ;;  <---- MULTIPLE
----

The data values for all 
the nominated profiles will be composed to form the final `:http` specification. 

But how? How are they composed? 

=== Composing Profiles

Each profile represents a map of `:http` values. So, when we have multiple `ids` we will have multiple 
"maps". So how should multiple maps be "combined" to form a final map, which will act as the 
`:http` specification?  

This is best understood by imagining a `reduce` across maps. 

Consider:
[source, Clojure]
----
(reduce merge {}  [map1, map2, map3])
----
It will `merge` multiple maps into one. The key/value pairs in the maps will be  
accumulated, with any values in "later" maps overwriting the values in earlier ones. 


[source, Clojure]
----
(def map1 {a: 1})
(def map2 {b: 2})
(def map3 {a: 11})

(reduce merge {}  [map1, map2, map3])
----
results in `{a: 11  :b 2}`. 

You'll notice how `:a` has the value `11`, not `1` because the value for `:a` in `map3` overwrites the earlier value in `map1`. 

Next, notice that `merge` is shallow. 

[source, Clojure]
----
(def map1 {a: {:aa 1})
(def map2 {b: 2})
(def map3 {a: {:cc 1})

(reduce merge {}  [map1, map2, map3])
----
You might mistakenly think the result should be: 
`{a: {:aa 1 :cc 1}  :b 2}`. 

But it is actually: `{a: {:cc 1}  :b 2}`. 

The `:a` value of `map3` simply replaces the **completely** the earlier value. `merge` is shallow. 



   
== About State

XXX Should we have the `Issued state` which allows you to:

   - set twirly state?
   - obtain the id?
   
   
XXX There's three kinds of state to talk somewhere:

* Logical State (of the FSM) 
* request-state
* app-db state at a path




