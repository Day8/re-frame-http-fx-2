:source-highlighter: coderay
:source-language: clojure
:toc:
:toc-placement: preamble
:sectlinks:
:sectanchors:
:toc:
:icons: font

> This library is under development, so don't try to use it yet. + 
> But this README/tutorial is almost done, and it explains how it will work. + 
> Please have a read and give us your ideas or critique. Or,
> more casually, tweet me @wazound

image:https://circleci.com/gh/Day8/re-frame-http-fx-2.svg?style=svg["CircleCI", link="https://circleci.com/gh/Day8/re-frame-http-fx-2"]


== Easy and Robust HTTP Requests

A re-frame library for performing HTTP requests using an effect with key `:http`

== Overview

HTTP requests are simple, right?

You send off a request, you get back a response, and you store it in `app-db`.
Done.

Except, of course, _**requests are anything but simple**_.  There is a happy
path, yes, but it winds through a deceptively dense briar thicket of fiddly
issues. Coding for unreliable servers and unreliable networks using an async
flow of control is hard enough, what with the multiple failure paths
and possible retries but, on top of that, there's also the
*_cross-cutting issues_* of managing UI updates, user-initiated cancellations,
error recovery, logging, statistics gathering, etc. There's a bit going on.

Many programmers instinctively shy away from the tentacles of this complexity,
pragmatically preferring naive but simple solutions. And yet, even accepting
that trade-off, they can find themselves with an uncomfortable amount of
repetition and boilerplate.

This library has two goals:

  1. proper treatment for failure paths (robustness and a better user experience)
  2. you write less code for each request (no repetition or fragile boilerplate)

These two goals would typically pull in opposite directions, but this library
liberates you from the horns of this dilemma and seeks to let you have your
cake and eat it too. In fact, maybe even eat it twice.  But no chocolate
sprinkles. We're not monsters.

== An Indicative Code Fragment 

Here's a re-frame event handler returning an effect keyed `:http`. 

[source, Clojure]
----
(ref-event-fx 
  :switch-to-articles-panel
  (fn [{:keys [db]} _]
    ;; Note the following :http effect
    {:http {:get  "http://api.something.com/articles/"
            :path [:put :response :data :at :this :path :in :app-db]}}))
----


That `:http` effect will GET from the given URL and place any response data into
`app-db` at the given path. The request will be retried on timeouts, and 503
failure, etc. Logs will be written, errors will be reported, and interesting
statistics will be captured. The user will see a busy-twirly and be able to
cancel the request by hitting a button. The response data can be processed from
JSON and transit into EDN, before ending up at the right place in `app-db`.

So with two lines of code - simple ones at that - you'll get an excellent robust HTTP
request process. However, as you'll soon see, there's no magic happening to
achieve the outcome. You do need to *_compose the right defaults_*.

If there is a cost - and there is *_always_* a cost for abstraction - it is that
you'll need to do some upfront learning, and need to fashion these
*_right defaults_*. Let's begin the upfront learning process now ...

== An Overview

I have some good news and some bad news â€” first, the good news.

This library models an HTTP request using a Finite State Machine (hereafter FSM)
- one which captures the various failure paths and retry paths, etc. And that
leads to a robust and understandable request process.

Also, this library wraps `fetch`, making it central to the FSM, and that delivers a browser-modern way to do the network layer.

So, that's the end of the good news. The bad news is that you'll be doing the rest of the work. 

This library leaves parts of the FSM unimplemented, and it asks that you fill in
these blanks by writing a number of *_Logical State Handlers_*.

Each `Logical State Handler` provides the behaviour for a single
*_Logical State_* in the FSM.  To help you, this library offers "a task recipe"
for each handler, describing what your implementation is expected to do. So, for
example, in the `Failed` state, the recipe might say that you "perform error
reporting" and "recover the application into a stable state, in light of the
failure".

Of course, there are many ways to implement both of these tasks and only
you, the application programmer, know how to make it happen correctly for your
application.  And that's precisely why the FSM is left incomplete and why you are
asked to fill in the blanks.

NOTE: With a bit of squinting and head tilting, you can see a
*_Logical State Handler_* as something of a *_callback_*. For example, writing a
`Logical State Handler` for the `Failed State` is very similar to supplying an
`on-failure` callback. As we'll soon see, there is slightly more going on, but
that's a pretty good first approximation. And, of course, because we're in
re-frame land, the mechanism will be more `dispatch-back` than `callback`.

Each `Logical State Handler` you write has to be something of a "good citizen"
within the overall composition (follow the task recipe). If your
`Logical State handler` fails to do the right thing, any FSM you compose using
it will be, to some extent, dysfunctional. I have every confidence in you.

Later, once you have written the necessary set of `Logical State Handlers`, you
*_compose them to form a functioning FSM_*. And, because this is a ClojureScript
library, this composition happens in a *_data oriented_* way.

If your application's needs are sufficiently complicated, you can create
multiple FSM compositions within the one app, with each configuration designed
for a different kind of request.

And, if you use one regularly, you can nominate it to be
*_the default FSM_*. That two-line example shown earlier owes its brevity to
(implicitly) using a `default` FSM composition.

Finally, to round off this overview, we note that each FSM instance has some
working state, which we call `request-state`. In addition, there will likely be
some state stored within `app-db` which is also associated with a request. Your
`Logical State handlers` will be responsible for pushing/projecting parts of
`request-state` through into `app-db`, so that your UI can reflect the state of
the request. Again, only you, the application programmer, know how you want this
done, although we will certainly be suggesting some useful patterns. For
example, you might write a `:retrying?` value of `true` into `app-db` which then
causes the UI to render "Sorry about the delay. There was a problem with the
network connection, so we're trying again".

So, here's the plan: 

* you should get to know the FSM topology it proposes (in the next section)
* you will implement the blank parts of the FSM but writing a set of
`Logical State handlers`, following the recipe for each.
* you will *_compose an ensemble_* of these `Logical State handlers` to form a FSM
* your FSM will maintain/manage `request-state`
* your FSM will likely push/project aspects of `request-state` into `app-db` 
* you will write views in terms of what's projected into `app-db`, showing the
user what's happening
* and when the time comes, when you make the HTTP request, you'll be
nominating which FSM to use (or you will implicitly be using your default FSM)


== The FSM

An HTTP request is a multi-step process which plays out over time.

We formalise it as *_a machine_*, and specifically a Finite State Machine
(FSM). The Internet is full of excellent resources describing FSMs, so here I'll
be brief.

By *_a machine_*, I'm referring to the abstract concept of something which
*_does something_*.

With an FSM the *_machine_* has a set of *_Logical States_* and *_Transitions_*
defined between them.  *_Logical States_* are a way to reason about *_where_* a
machine is within an overall process. Each Logical State has discrete
responsibilities, concerns and behaviours.

*_Transitions_* cause an FSM to move from one Logical State to another - from one
behaviour to another. Over time - and I really would like to stress this time
bit - events occur which *_trigger_* Transitions. That means an FSM goes from
doing one thing to doing another thing.

The `Logical State Handlers` you write are about "doing a thing" when in a
particular state. And, so, they implement behaviour for one part of "the
machine".

The FSM at the core of this library is as follows: 

image::http://www.plantuml.com/plantuml/png/ZLDDJnjD3BxFhx32vULLKL4lI564W4YeXnvGgTG3os5sno4ZTksjnmDQLVtldVreEbcQjBxPypoFF-ov2cf5OrCRvHQKeMHLRi1vmKez4vYjTmZOjDg1mr29R_kuCU7PKsl5DX2srl6hfoVOs3fWzbBQwlb9E99RSyq29xV9SgPQHVXk0E26nQ5CiElhQmFmbhvUhmViVdorWe-sRRixgzlBI_ZadxPwKqUSoSvWdxcpzG3xOOmPArdSeyPs0OFP08CBewrM6ViN_glrcXfVJFZ9FOo_4wumX86IyB_T0_ZxM5M83jrYqD-vX_I_e9Mq2rh0WDV9XJTuOxBSIsX71tIB81XQfe1GiklU5MJ9GLlR2i4hU8AaSkPAa_MwX0qBM23KLvPdg9XeF9-HRI6WlA3if8qn3_y_mcHd3oUxPJoUNSAjzJKw69KzlTZQku84lqKCUeoOhMi9Cvh97kUylLO2aeFti46jjiEKoXgRYNLnST7ZHzjZ2QfqEzeHrbvpc-GKL69bOq1GPcWiTGNrQXu3i02Ai80F1SKKhZYDqIPjayz_dYDBlmJr3NBKVyP72lsLXR29gRR__hHJbccXOtMdkVPyjdjdDYadsVvUOu0Fv-UdnofRMwgm7WQs15koQEBsHne3Ia6AqdYoYgwWFZej-zG0vFTzT0Vj3bVGq4xEd7Up-u0P4vqnMNnEoVxW4XmJcYpzlBAtu6m2VmURB3Il8_it2Or1XJjpXUHYK_y4[FSM,600]


Notes:

* to use this library, you'll need to understand this FSM
* the boxes in the diagram represent the FSM's *_Logical States_*
* the lines between the boxes are the allowed changes between *_Logical States_*,
known as *_Transitions_*
* the names on those lines are the *_Triggers_* (the event which causes the
Transition to happen)
* when you write a `Logical State Handler` you are implementing the behaviour
for one of the boxes
* the "happy path" is shown in blue  (both boxes and lines)
* and, yes, there are variations on this FSM model of a request - this one is
ours. We could, for example, have teased the "Problem" Logical State out into
four distinct states: "Timed Out", "Connection Problem", "Recoverable Server
Problem" and "Unrecoverable Server Problem".  We decided not to do that because of, well, reasons. My point is that there isn't a "right" model, just one that is fit for purpose.

== Requesting

Earlier, we saw this code: 

[source, Clojure]
----
(ref-event-fx 
  :switch-to-articles-panel
  (fn [{:keys [db]} _]
    ;; Note the following :http effect
    {:http {:get  "http://api.something.com/articles/"
            :path [:put :response :data :at :this :path :in :app-db]}}))
----

It uses an effect `:http` to initiate an HTTP GET request. 

Who doesn't love terse? But, as a learning exercise, 
let's pendulum to the opposite extreme 
and show you *_the most verbose_* use of the
`:http` effect:
[source, Clojure]
----
(reg-event-fx
  :request-articles
  (fn [_ _]
    {:http  {:get        "http://api.something.com/articles/"

             ;; Compose the FSM
             ;; Nominate the `Logical State handlers` to be used for this request.
             ;; Look back at the FSM diagram and at the boxes which represented 
             ;; Logical States. We are nominating what handler will implement the 
             ;; behaviour in each Logical State (each box of the diagram). 
             ;;
             ;; When the request transitions to a new Logical State, it will `dispatch`
             ;; the event you nominate below, and the associated event handler is expected
             ;; to perform "the behaviour" required in that Logical State.
             :in-setup      [:my-setup]
             :in-process    [:my-processor]
             :in-problem    [:deep-think :where-did-I-go-wrong]
             :in-failed     [:call-mum]
             :in-cancelled  [:generic-cancelled]
             :in-succeeded  [:yah! "fist-pump" :twice]
             :in-teardown   [:so-tired-now]
             
             
             :params     {:user     "Fred"
                          :customer "big one"}
             :headers    {"Authorization"  "Bearer QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
                          "Cache-Control"  "no-cache"}

             ;; XXX describe this 
             :content-type {#"application/.*json" :json
                            #"application/edn"    :text}

             ;; Timeout
             ;; optional, by default request will run as long as browser implementation allows
             :timeout       5000

             :credentials   "omit" ;; default is 'include'
             :redirect      "manual" ;; default is 'follow'
             :mode          "cors" ;; default is 'same-origin'
             :cache         "no-store" ;; default is 'default' ref https://developer.mozilla.org/en-US/docs/Web/API/Request/cache
             :referrer      "no-referrer" ;; default is 'client'
             
             ;; ref https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
             :integrity     "sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE="

             ;; NOTE: GET or HEAD cannot have body!  XXX
             :body          String | js/ArrayBuffer | js/Blob | js/FormData | js/BufferSource | js/ReadableStream

             ;; Optional: the path within `app-db` to which request related data should be put
             ;; See section in these docs called `path state`  for more details 
             :path [:put :response :data :at :this :path :in :app-db]

             ;; Optional: an area to put application-specific data 
             ;; If data is supplied here, it will probably be used later within the 
             ;; implementation of a "state handler". For example "description"
             ;; might be a useful string for displaying to the users in the UI or
             ;; to put in errors or logs.
             :context {:max-retries  5
                            :description  "Loading articles"}}))
----

XXX add optional  `:cancel` event handler ?? + 
XXX add an interceptor to assert the correctness of the Logical State Handlers + 

This specification offers a lot of flexibility. But we clearly don't want to repeat this much every time. Mainly because, time after time,
we'll likely want the same headers, params and `Logical State handers`.

== Profiles

A *_profile_* is a fragment of an `:http` specification. It associates an 
`id` with a set of specifications. 

You can "register" one or more *_profiles_*, typically on application 
startup.

An `:http` specification is just data (a map) which means a fragment is also 
just data (again, a map). 
And if you think that sounds pretty simple, you'd be right.


== Registering A Profile

This code shows how to register a profile with id `:xyz`, and associate 
it with certain specification values:
[source, Clojure]
----
(reg-event-fx
   :register-my-http-profile
   (fn [_ _]

      {:http   {;; Notice the use of `:reg-profile`
                ;; The value `:xyz` is the `id` of the profile being registered
                ;; The special value of `:default` says that this profile
                ;; should be used for all requests, unless otherwise overridden.
                ;;  You can register multiple profiles
                
                :reg-profile   :xyz

                ;; Sets this profile as the 'default'.
                :default? true
      
                ;; the values we are capturing and associating with this profile 
                :values {
                          ;; compose the FSM
                          :in-process    [:my-processor]
                          :in-problem    [:generic-problem :extra "whatever"]
                          :in-failed     [:my-special-failed]
                          :in-cancelled  [:generic-cancelled]
                          :in-teardown   [:generic-teardown]

                          :timeout       3000

                          :context  {:max-retries 2}}}}))
----

XXX where do we talk about default.

== Using A Profile

Here's an example of using that profile we registered above: 
[source, Clojure]
----
{:http {:get      "http://api.endpoint.com/articles/"
        :path     [:put :response :data :at :this :path :in :app-db]
        :profiles [:xyz]}}     ;;  <--- NEW: THIS IS HOW WE SAY WHAT PROFILE(S) TO USE
----

That key `:profiles` allows you to nominate a vector of previously registered `profile` `ids`. The data
(`:values`) associated with those profile  `ids` will be added in the request.

Here's another example use, but this time with multiple profile ids (a `vector` of them):
[source, Clojure]
----
{:http {:get      "http://api.endpoint.com/articles/"
        :path     [:put :response :data :at :this :path :in :app-db]
        :profiles [:jwt-token :standard-parms :xyz]}}     ;;  <---- MULTIPLE
----

The data in the `:values` for the nominated profiles will be composed to form the
final `:http` specification. 

But how? 

=== Composing Profiles

When each profile holds a `:values` map and we must compose multiple of them - how should
we "combine" the many maps into one, final map which is our `:http` specification?  

The answer is to imagine a `reduce` across a seq of maps, using `merge`:
[source, Clojure]
----
(reduce merge {}  [map1, map2, map3])
----
`merge` will accumulate the key/value pairs. Instead of `map1`, `map2`, etc, imagine that 
it was actually `profile`, `profile2, etc. 

Example #1:
[source, Clojure]
----
(def map1 {a: 1})
(def map2 {b: 2})
(def map3 {c: 11})

(reduce merge {}  [map1, map2, map3])
----
the result is `{a: 1  :b 2  :c 11}`.  

The process is straightforward while ever the maps have disjoint keys. But when that isn't true,
values in "later" maps overwrite values in "earlier" ones. 

Example #2:
[source, Clojure]
----
(def map1 {a: 1})
(def map2 {b: 2})
(def map3 {a: 11})

(reduce merge {}  [map1, map2, map3])
----
the result is `{a: 11  :b 2}`. 

You'll notice that the key `:a` is in both `map1` and `map3`. In the result, `:a` has the value `11`, not `1`, 
because the value in `map3` overwrites the earlier value in `map1`. 

Also, remember that `merge` is shallow. Consider:
[source, Clojure]
----
(def map1 {a: {:aa 1})
(def map2 {a: {:cc 1})

(reduce merge {}  [map1, map2])
----
You might be tempted to think the result should be
`{a: {:aa 1 :cc 1}}`
but it is actually: `{a: {:cc 1}}`. 

The `:a` value in `map2`, which is `{:cc 1}`, simply replaces **completely** the earlier value of `{:aa 1}`. The values `{:aa 1}` and `{:cc 1} are not themselves merged because `merge` is shallow and does not act deeply/recursively on the map values themselves.

== Beyond Default `merge` Behaviour

Often, this default `merge` behaviour is good enough, particularly when the profiles have disjoint keys. 

But when the profiles have overlapping keys it can be useful to take control of how map `values` are combined. 

[source, Clojure]
----
(reg-event-fx
   :register-my-http-profile
   (fn [_ _]
      {:http   {:reg-profile   :xyz
      
                ;; the values we are capturing and associating with this profile 
                :values {;; compose the FSM
                         :in-process    [:my-processor]
                         :in-problem    [:generic-problem :extra "whatever"]
                         :in-failed     [:my-special-failed]
                         :in-cancelled  [:generic-cancelled]
                         :in-teardown   [:generic-teardown]

                         :timeout       3000

                         :context  {:max-retries 2}}}}))
                
                ;; Optional, advanced feature.
                ;; Profiles themselves can be combined/composed.
                ;; In this section, you can specify how the `:values` in this
                ;; profile should be combined with the values of another profile. 
                ;; For each potential key in `:values` provide you can provide a two argument
                ;; function to do the combining. 
                ;; The two arguments given to this function will be:
                ;;    (1) the value in "other" profile 
                ;;    (2) the value in this profile
                ;; 
                ;; Example combining functions:
                ;;    - `merge` would be useful if combining maps
                ;;    - `conj` would be useful for combining vectors
                ;;    - `str` would be useful for combining strings (URI?)
                ;;    - `#(identity %2)` would cause the value in this profile
                ;;      overwrite the value in the other profile. 
                ;; 
                :combine   {:params   merge
                            :get      str}}}))
----

XXX is there a default "combiner" for each key in `:values`? + 
XXX where is this documented? + 

= About State

XXX this section is messy and incomplete .... 

There are two kinds of State:

* `request-state` is detail about a request, maintained by this library  in the
   course of getting its job done. It represents the "working memory" of the FSM
   and it only exists for the lifetime of a request. It includes data such as an
   id, the current logical state of the FSM, the original request, current
   number of retries, a trace history through the FSM including timings, etc.
   This state is stored internally in the library and provided in the event
   vector to *_Logical State Handlers_*.

* `app-state` - this is the application state which represents the request (not
   the library's state). It is a small map of values which exists at a
   particular path within `app-db` and the contents of this map is up to you,
   the writer of the application. It will be created and maintained by the
   *_Logical State Handlers_* you write and it will always be "a materialised
   view" of the full `request-state`.
  
XXX better names? Maybe `lib-state` and `app-state`. Not keen on `app-state`.  `your-state`  `ui-state`
  
Typically, the `in-setup` state handler initialises this map, and it is 
then updated across the request handling process by the various FSM handlers. 

An example of the `app-state` map. 
[source, Clojure]
----
{
  :request-id  123456
  :loading?    true
  :error?      nil or "Something bad happened"
  :result      nil
  :retries     0
  :cancelled?  false
  :description "Loading filtered thingos"
}
----

This is the data in `app-db` which some view functions might subscribe to, in
order to render the UI

XXX To avoid race conditions, should the booleans be false in absence via subscriptions?  Eg: use `completed?` instead of `loading?` because "absence" (a nil) correctly matches the predicate's negative value. 

XXX consider what else needs to happen to help `re-frame-async-flow`

So, I'd like to stress two points already made:
   - lifetime: `app-state` exists for as long as your application code says it should - it persists. Whereas 
     `request-state` is created and destroyed by this library - it is a means to an ends - it is transitory. 
   - during the request process, `request-state` tends to be authoritative. : `app-state` is something 
     of a projection or materialised view of `request-state`. (Not entirely true but a useful mental model at
     this early stage in explanation)

While `app-state` ....  there might need to be a `:loading?` value      set to true to indicate that the busy twirly should be kept up.  Or perhaps a `:retrying?` flag might need to be "projected" from the    `reguest-state` so that, again, the UI can show the user what is happening.  

Ultimately, the most important part of this `app-state` is the (processed) response data itself. But there will be other information alongside it. For this reason, `presentation-state` is normally a map of values with a key for `response`, but it has other values.

The `app-state` is managed by your `Logical State Handlers`. You control what data is projected from the `request-state` across into the `presentation-state`. Because you, the application programmer, knows what you want to set within `app-db`. You know how you want the UI to render the state of the request process.

For example:
  - it is the job of the `in-setup` to initially create the  `XXX-state` assumed to be a map. 
    And it might initially establish within this map a `:loading?` flag as `true`. 
  - it is then the job of the `in-teardown` handler to set the `:loading?` flag back to `false`
    (thus taking down the twirly). 
    
    
= Logical State Hander Recipes 


.To use this library, you'll:
* design `app-state` and the views which render it (or simply use the default design suggested)
* implement your Logical State Handlers (or simply use the default handlers provided)

The Logical State Handlers you write are about "executing the behaviour" associated with being _*in_* a particular state within the FSM. They implement behaviour for one part of "the machine".

The Logical State Handlers have responsibility for mirroring a view of `request-state` across into `app-state`.

Recipes for each of the Logical State Handlers ... 

=== in-setup

Overview: prepare the application for the pending HTTP request. 

.Recipe:
* establish initial `app-state` at the nominated `:path`
* optionally, if the application is to allow the user to cancel the request
(e.g., via a button) then capture the `:request-id` of the request and assoc it
into `app-state` for easy access.
* optionally, put up a twirly-busy-thing, perhaps with a description of the
request: "Loading all the blah things", probably with a cancel button
* optionally, cause the application to change panel or view to be ready for the
incoming response data.
* trigger `:send` to cause the transition to `waiting`, with the `:send` being
an action associated with the transition.


Views subscribed to this `app-state` will then render the UI, probably locking
it up and allowing the user to see that a request is in-flight.

XXX a panel might change .... perhaps the user clicked a button to "View Inappropriate", so the application will change panels to the inappropriate one (via a change in `app-db` state), AND also kickoff a server request to get the "inappropriates".

Example implementation:
[source, Clojure]
----
(fn [{:keys [db] :as cofx} [_ {:keys [request-id context] :as request-state}]]
  (let [path (:path context)]
    {:http  {:trigger :send
             :request-id request-id}
     :db    (-> db
              (assoc-in (conj path :request-id) request-id)
              (assoc-in [:global :loading?] true)
              (assoc-in [:global :loading-text] (:loading-text context)))}))
----

XXX once preparation is complete, notice that your code is expected to `trigger` the transition.

=== in-waiting

This State Handler is unique because it is the only one you can't write. It is
provided by this library.

In this state, we are waiting for an HTTP response (after the `fetch` is
launched) and any subsequent initial processing of the response body by the
browser.

=== in-processing

.Recipe:
* Process the response: turn transit JSON into transit or 
* store in app
* FSM trigger `processed`

Example implementation
[source, Clojure]
----
(fn [{:keys [db] :as cofx} [_ {:keys [request-id response context] :as request-state}]]
  (let [path (:path context)
        reader (transit/reader :json)]
    (try
      (let [data (transit/read reader (:body response))]
        {:db (assoc-in db (conj path :data) data)
         :http {:trigger :processed
                :request-id request-id}}))
      (catch js/Error e
        {:db   (-> db
                 (assoc-in (conj path :error) :transit-reader))
         :http {:trigger :fail
                :request-id request-id}})))
----

=== in-succeeded

The processing of the response has succeeded.

.Recipe:
* FSM trigger `:done`

Example implementation
[source, Clojure]
----
(fn [{:keys [db] :as cofx} [_ {:keys [request-id] :as request-state}]]
  {:http {:trigger :done
          :request-id request-id}})
----

=== in-problem

.Recipe:
* decide what to do about the problem - retry or give up? 
* FSM trigger `:fail` or `:retry`

Example implementation:
[source, Clojure]
----
(fn [{:keys [db] :as cofx} [_ {:keys [request-id context problem response] :as request-state}]]
  (let [path (:path context)
        temporary? (= :timeout problem)
        max-retries (:max-retries context)
        num-retries (get-in db (conj path :num-retries request-id) 0)
        try-again? (and (< num-retries max-retries) temporary?)]
    (if try-again?
      {:http {:trigger :retry
              :request-id request-id}
       :db (update-in db (conj path :num-retries request-id) inc)}
      {:http {:trigger :fail
              :request-id request-id}})))
----

.Full taxonomy of problems:
* network connection error - no response - retry-able (except that DNS issues take a long time, so retires are annoying)
  ** cross-site scripting whereby access is denied; or
  ** requesting a URI that is unreachable (typo, DNS issues, invalid hostname etc); or
  ** request is interrupted after being sent (browser refresh or navigates away from the page); or
  ** request is otherwise intercepted (check your ad blocker).
* `fetch` API body processing error; e.g. JSON parse error.
* timeout - no response - retry-able
* non 200 HTTP status - returned from the server - MAY have a response
** may have a response :body returned from server which will need to be processed. See https://tools.ietf.org/html/rfc7807 Imagine a 403 Forbidden response. XXX talk about how it might be EDN or a Blob etc.
* some HTTP status are retry-able and some are not

=== in-failed

The request has failed and we must now adjust for that. 

Ultimately, it doesn't actually matter why we are in the failed state, but to help give context, here's the sort of reasons we end up in this state:
* no outright failure, but too many retries (see `:history` XXX for what happened)
* some kind of networking error happened which means the request never even got to the target server (CORS, DNS error?)
* the server failed in some way (didn't return a 200) 
* a 200 response was received but an error occurred when processing that response


.Recipe:
* log the error
* show the error to the user
* put the application back into a sane state
* FSM trigger `:teardown`

Example implementation:
[source, Clojure]
----
(fn [{:keys [db] :as cofx} [_ {:keys [request-id context problem response] :as request-state}]]
  (let [path (:path context)]
    {:http {:trigger :teardown
            :request-id request-id}
     :db (-> db
             ...)}))
----

=== in-cancelled

This state follows user cancellation. 

.Recipe:
* put the application into a state consistent with the cancellation. What does
the user see? What can they do next?
* update `app-state`, maybe. 
* FSM trigger `:teardown`

Example implementation:
[source, Clojure]
----
(fn [{:keys [db] :as cofx} [_ {:keys [request-id context problem response] :as request-state}]]
  (let [path (:path context)]
    {:http {:trigger :teardown
            :request-id request-id}
     :db (-> db
             ...)}))
----

=== in-teardown

Irrespective of the outcome of the request (success, cancellation or failure), this state occurs immediately before it completes. 

As a result, in this state we handle any actions which have to happen irrespective of the outcome.

.Recipe:
* take down the twirly 
* accumulate and log final stats 
* possible updates to `app-state`
  * change `:loading?` to false
* possible updates to `app-db` 
  * busy twirly removal
* FSM trigger `:destroy`

Example implementation:
[source, Clojure]
----
(fn [{:keys [db]} [_ {:keys [request-id context] :as request-state}]]
  (let [path (:path context)]
    {:http {:trigger :destroy
            :request-id request-id}
     :db (-> db
           (assoc-in [:global :loading?] false))}))
----




