:source-highlighter: coderay
:source-language: clojure
:toc:
:toc-placement: preamble
:sectlinks:
:sectanchors:
:toc:
:icons: font

> This library is under development. <br>
> We're interested in your ideas or critique. Please open an issue. Or tweet me @wazound

image:https://circleci.com/gh/Day8/re-frame-http-fx-2.svg?style=svg["CircleCI", link="https://circleci.com/gh/Day8/re-frame-http-fx-2"]


== Easy and Robust HTTP Requests

A re-frame library for performing HTTP requests using an effect with key `:http`

== Overview

HTTP requests are simple, right?

You send off a request, you get back a response and you store it in `app-db`. Done.

Except, of course, _**requests are anything but simple**_.  There is a happy path, yes, but it winds through a deceptively dense briar thicket of fiddly issues. Coding for unreliable servers and unreliable networks using an async flow of control is hard enough by itself, what with the multiple failure paths and possible retries but, on top of that, there's also the *_cross-cutting issues_* of managing UI updates, user-initiated cancellations, error recovery, logging, statistics gathering, etc. There's a bit going on.

Many programmers instinctively shy away from the tentacles of this complexity, pragmatically preferring naive but simple solutions. And yet, even accepting that tradeoff, they can find themselves with an uncomfortable amount of repetition and boilerplate.

This library has two goals:

  1. proper treatment for failure paths (robustness and a better user experience)
  2. you write less code for each request (no repetition or fragile boilerplate)

These two goals would normally pull in opposite directions but this library liberates you from the horns of this dilemma, and seeks to let you have your cake and eat it too. In fact, maybe even eat it twice.  But no chocolate sprinkles - we're not monsters.

== An Indicative Code Fragment 

Here's a re-frame event handler returning an effect keyed `:http`. 

[source, Clojure]
----
(ref-event-fx 
  :switch-to-articles-panel
  (fn [{:keys [db]} _]
    ;; Note the following :http effect
    {:http {:http/get  "http://api.something.com/articles/"
            :http/path [:put :response :data :at :this :path :in :app-db]}}))
----


That `:http` effect will GET from the given URL and place any response data into `app-db` at the given path. The request will be retried on timeouts, and 503 failure, etc. Logs will be written, errors will be reported and interesting statistics will be captured. The user will see a busy-twirly and be able to cancel the request by hitting a button. The response data can be proccessed from JSON and transit into EDN, before ending up at the right place in `app-db`. 

So with two lines of code - simple ones at that - you'll get a good robust HTTP request process. However, as you'll soon see, there's no  magic happening to achieve the outcome. You do need to *_compose the right defaults_*.

If there is a cost - and there is *_always_* a cost for abstraction - it is that you'll need to do some upfront learning, and need to fashion these *_right defaults_*. Let's begin the upfront learning process now ...

== An Overview

I have some good news and some bad news. Good news first.

This library models an HTTP request using a Finite State Machine (hereafter FSM) - one which captures the various failure paths and retry paths, etc. And that leads to a robust and understandable request process. 

Also, this library wraps `fetch`, making it central to the FSM, and that means the network-level mechanics of a request are supplied in a browser-modern way.

So, that's the end of the good news. The bad news to that you do the rest of the work.

This library leaves parts of the FSM unimplemented and it asks that you fill in these blanks by writing a number of *_Logical State Handlers_*. 

Each `Logical State Handler` provides the behaviour for a single *_Logical State_* in the FSM.  To help you, this library provides  "a task recipe" for each handler, describing what your implementation is expected to do. So, for example, in the `Failed` state, the recipe might say that you "perform error reporting" and "recover the application into a stable state, in light of the failure".

Of course, there's a myriad of ways to implement both of these tasks and only you, the application programmer, know how to make it happen correctly for your application.  And that's exactly why the FSM is left incomplete and why you are asked to fill in the blanks.

NOTE: With a bit of squinting and head tilting, you can see a *_Logical State Handler_* as something of a *_callback_*. For example, writing a `Logical State Handler` for the `Failed State` is very similar to supplying an `on-failure` callback. As we'll soon see, there is slightly more going on, but that's a pretty good first approximation. And, of course, because we're in re-frame land, the mechanism will be more `dispatch-back` than `callback`.

Each `Logical State Handler` you write has to be something of a "good citizen" within the overall composition (follow the task recipe). If your `Logical State handler` fails to do the right thing, any FSM you compose using it will be, to some extent, dysfunctional. I have every confidence in you.

Later, once you have written the necessary set of `Logical State Handlers`, you *_compose them to form a functioning FSM_*. And, because this is a ClojureScript library, this composition happens in a *_data oriented_* way. 

If your application's needs are sufficiently complicated, you can create multiple FSM compositions within the one app, with each configuration designed for a different kind of request.

And, if one of them is used more regularly, you can nominate it to be *_the default FSM_*. That two line example shown earlier owes its brevity to (implicitly) using a `default` FSM composition. 

Finally, to round off this overview, we note that each FSM instance has some working state, which we call `request-state`. In addition, there will likely be some state in `app-db` which is also associated with a request. Your `Logical State handlers` will
be responsible for pushing/projecting parts of `request-state` through into `app-db`, so that your UI can reflect the state of the request. Again, only you, the application programmer, know how you want this done, although we will certainly be suggesting some useful patterns. For example, you might write a `:retrying?` value of `true` into `app-db` which then causes the UI to render "Sorry about the delay. There was a problem with the network connection, so we're trying again".

So, here's the plan: 

* you should get to know the FSM topology it proposes (in the next section)
* you will implement the blank parts of the FSM but writing a set of `Logical State handlers`, following the recipe for each. 
* you will compose an ensemble of these `Logical State handlers` to form a FSM
* your FSM will maintain/manage `request-state`
* your FSM will likely push/project aspects of `request-state` into `app-db` 
* you will write views in terms of what's projected into `app-db`, showing the user what's happening 
* and when the time comes, when you actually make the HTTP request, you'll be nominating which FSM to use (or you will implicitly be using your default FSM)


== The FSM

An HTTP request is a multistep process which plays out over time. 

We formalise it as a *_a machine_*, and specifically a Finite State Machine (FSM). The Internet is full of excellent resources describing FSMs, so here I'll be brief. 

By *_a machine_*, I'm referring to the abstract concept of something which *_does something_*. 

With a FSM the *_machine_* has a set of *_Logical States_* and *_Transitions_* defined between them.  *_Logical States_* are a way to reason about *_where_* a machine is within an overall process. Each Logical State has discrete responsibilities, concerns and behaviours. 

*_Transitions_* cause a FSM to move from one Logical State to another - from one behaviour to another. Over time - and I really would like to stress this time bit - events occur which *_trigger_* Transitions. That means a FSM goes from doing one thing, to doing another thing.

The `Logical State Handlers` you write are about "doing a thing" when in a particular state. And, so, they implement behaviour for one part of "the machine". 

The FSM at the core of this library is as follows: 

image::http://www.plantuml.com/plantuml/png/ZLDDJnjD3BxFhx32vULLKL4lI564W4YeXnvGgTG3os5sno4ZTksjnmDQLVtldVreEbcQjBxPypoFF-ov2cf5OrCRvHQKeMHLRi1vmKez4vYjTmZOjDg1mr29R_kuCU7PKsl5DX2srl6hfoVOs3fWzbBQwlb9E99RSyq29xV9SgPQHVXk0E26nQ5CiElhQmFmbhvUhmViVdorWe-sRRixgzlBI_ZadxPwKqUSoSvWdxcpzG3xOOmPArdSeyPs0OFP08CBewrM6ViN_glrcXfVJFZ9FOo_4wumX86IyB_T0_ZxM5M83jrYqD-vX_I_e9Mq2rh0WDV9XJTuOxBSIsX71tIB81XQfe1GiklU5MJ9GLlR2i4hU8AaSkPAa_MwX0qBM23KLvPdg9XeF9-HRI6WlA3if8qn3_y_mcHd3oUxPJoUNSAjzJKw69KzlTZQku84lqKCUeoOhMi9Cvh97kUylLO2aeFti46jjiEKoXgRYNLnST7ZHzjZ2QfqEzeHrbvpc-GKL69bOq1GPcWiTGNrQXu3i02Ai80F1SKKhZYDqIPjayz_dYDBlmJr3NBKVyP72lsLXR29gRR__hHJbccXOtMdkVPyjdjdDYadsVvUOu0Fv-UdnofRMwgm7WQs15koQEBsHne3Ia6AqdYoYgwWFZej-zG0vFTzT0Vj3bVGq4xEd7Up-u0P4vqnMNnEoVxW4XmJcYpzlBAtu6m2VmURB3Il8_it2Or1XJjpXUHYK_y4[FSM,600]


Notes:

* to use this library, you'll need to understand this FSM
* the boxes in the diagram represent the FSM's *_Logical States_*
* the lines between the boxes are the allowed changes between *_Logical States_*, known as *_Transitions_*
* the names on those lines are the *_Triggers_* (the event which causes the Transistion to happen)
* when you write a `Logical State Handler` you are implementing the behaviour for one of the boxes
* the "happy path" is shown in blue  (both boxes and lines)
* and, yes, there are variations on this FSM model of a request - this one is ours. We could, for example, have teased the "Problem" Logical State out into four distinct states: "Timed Out", "Connection Problem", "Recoverable Server Problem" and "Unrecoverable Server Problem".  We decided to NOT do that because of, well, reasons. My point is that there isn't a "right" model, just one that suits a purpose.


== Requesting

Earlier we saw this code: 

[source, Clojure]
----
(ref-event-fx 
  :switch-to-articles-panel
  (fn [{:keys [db]} _]
    ;; Note the following :http effect
    {:http {:http/get  "http://api.something.com/articles/"
            :http/path [:put :response :data :at :this :path :in :app-db]}}))
----

It uses an effect `:http` to initiate an HTTP GET request. 

That code was very terse. To enhance your understanding of `:http`, let's now pendulum to the opposite extreme and show you *_the most verbose_* use of the `:http` effect handler:  
[source, Clojure]
----
(reg-event-fx
  :request-articles
  (fn [_ _]
    {:http  {:http/get        "http://api.something.com/articles/"

             ;; Compose the FSM
             ;; Nominate the `Logical State handlers` to be used for this request.
             ;; Look back at the FSM diagram and at the boxes which represented 
             ;; Logical States. We are nominating what handler will implement the 
             ;; behaviour in each Logical State (each box of the diagram). 
             ;;
             ;; When the request transitions to a new Logical State, it will `dispatch`
             ;; the event you nominate below, and the associated event handler is expected
             ;; to perform "the behaviour" required in that Logical State.
             :http/in-setup      [:my-setup]
             :http/in-process    [:my-processor]
             :http/in-problem    [:deep-think :where-did-I-go-wrong]
             :http/in-failed     [:call-mum]
             :http/in-cancelled  [:generic-cancelled]
             :http/in-succeeded  [:yah! "fist-pump" :twice]
             :http/in-done       [:so-tired-now]
             
             
             :http/params     {:user     "Fred"
                               :customer "big one"}
             :http/headers    {"Authorization"  "Bearer QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
                               "Cache-Control"  "no-cache"}

             ;; XXX describe this 
             :http/content-type {#"application/.*json" :json
                                 #"application/edn"    :text}


             ;; Optional, defaults to (keyword (gensym "http-")) e.g. :http-123
             ;; Useful when you want to 
             :http/id            :my-xyz-request ;; otherwise defaults to (keyword (gensym "http-")) e.g. http-123

             ;; Timeout
             ;; optional, by default request will run as long as browser implementation allows
             :http/timeout       5000 

             :http/credentials   "omit" ;; default is 'include'
             :http/redirect      "manual" ;; default is 'follow'
             :http/mode          "cors" ;; default is 'same-origin'
             :http/cache         "no-store" ;; default is 'default' ref https://developer.mozilla.org/en-US/docs/Web/API/Request/cache
             :http/referrer      "no-referrer" ;; default is 'client'
             
             ;; ref https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
             :http/integrity     "sha256-BpfBw7ivV8q2jLiT13fxDYAe2tJllusRSZ273h2nFSE=" 

             ;; NOTE: GET or HEAD cannot have body!
             :http/body          String | js/ArrayBuffer | js/Blob | js/FormData | js/BufferSource | js/ReadableStream

             ;; Optional: the path within `app-db` to which request related data should be put
             ;; See section in these docs called `path state`  for more details 
             :http/path [:put :response :data :at :this :path :in :app-db]

             ;; Optional: an area to put application-specific data 
             ;; If data is supplied here, it will probably be used later within the 
             ;; implementation of a "state handler". For example "description"
             ;; might be a useful string for displaying to the users in the UI or
             ;; to put in errors or logs.
             :http/context {:max-retries  5
                            :description  "Loading articles"}}))
----

XXX add optional  `:http/cancel` event handler ??
XXX add interceptor to assert correctness of the Logical State Handlers

This specification offers a lot of flexibility. But we clearly don't 
want to repeat this much every time. Particularly because, time after time,
we'll likely want the same headers, params and `Logical State handers`.

== Profiles

A *_profile_* is a fragment of an `:http` specification. It associates an 
`id` with a common set of specifications. 

You can "register" one or more *_profiles_*, typically on application 
startup.

An `:http` specification is just data (a map) which means a fragment is also 
just data (again, a map). 
And if you think that sounds pretty simple, you'd be right.


== Registering A Profile

This code shows how to register a profile with id `:xyz`, and associate 
with it certain specification values:
[source, Clojure]
----
(reg-event-fx
   :register-my-http-profile
   (fn [_ _]

      {:http   {;; Notice the use of `:http/reg-profile`
                ;; The value `:xyz` is the `id` of the profile being registered
                ;; The special value of `:http/default` says that this profile
                ;; should be used for all requests, unless otherwise overridden.
                ;; Clearly, you can register multiple profiles
                
                :http/reg-profile   :xyz
      
                ;; the values we are capturing and associating with this profile 
                :http/values {   
                              ;; compose the FSM
                              :http/in-process    [:my-processor]
                              :http/in-problem    [:generic-problem :extra "whatever"]
                              :http/in-failed     [:my-special-failed]
                              :http/in-cancelled  [:generic-cancelled]
                              :http/in-done       [:generic-done]
                              
                              :http/timeout       3000
                              
                              :http/context  {:max-retries 2}}}}))               
----

XXX Isaac are we using `default? true` approach?
XXX where do we talk about default. 

== Using A Profile

Here's an example of using that profile we registered above: 
[source, Clojure]
----
{:http {:http/get      "http://api.endpoint.com/articles/"
        :http/path     [:put :response :data :at :this :path :in :app-db]
        :http/profiles [:xyz]}}     ;;  <--- NEW: THIS IS HOW WE SAY WHAT PROFILE(S) TO USE 
----

That key `:http/profiles` allows you to nominate a vector of previously registered `profile` `ids`. The data 
(`:http/values`) associated with those profile  `ids` will be added in the request. 

Here's another example use, but this time with multiple profile ids (a `vector` of them):
[source, Clojure]
----
{:http {:http/get      "http://api.endpoint.com/articles/"
        :http/path     [:put :response :data :at :this :path :in :app-db]
        :http/profiles [:jwt-token :standard-parms :xyz]}}     ;;  <---- MULTIPLE
----

The data in the `:http/values` for the nominated profiles will be composed to form the 
final `:http` specification. 

But how? 

=== Composing Profiles

When each profile holds a `:http/values` map and we must compose multiple of them - how should 
we "combine" the many maps into one, final map which is our `:http` specification?  

The answer is to imagine a `reduce` across a seq of maps, using `merge`:
[source, Clojure]
----
(reduce merge {}  [map1, map2, map3])
----
`merge` will accumulate the key/value pairs. Instead of `map1`, `map2`, etc, imagine that 
it was actually `profile`, `profile2, etc. 

Example #1:
[source, Clojure]
----
(def map1 {a: 1})
(def map2 {b: 2})
(def map3 {c: 11})

(reduce merge {}  [map1, map2, map3])
----
the result is `{a: 1  :b 2  :c 11}`.  

The process is straight forward while ever the maps have disjoint keys. But when that isn't true,
values in "later" maps overwrite values in "earlier" ones. 

Example #2:
[source, Clojure]
----
(def map1 {a: 1})
(def map2 {b: 2})
(def map3 {a: 11})

(reduce merge {}  [map1, map2, map3])
----
the result is `{a: 11  :b 2}`. 

You'll notice that the key `:a` is in both `map1` and `map3`. In the result, `:a` has the value `11`, not `1`, 
because the value in `map3` overwrites the earlier value in `map1`. 

Also, remember that `merge` is shallow. Consider:
[source, Clojure]
----
(def map1 {a: {:aa 1})
(def map2 {a: {:cc 1})

(reduce merge {}  [map1, map2])
----
You might be tempted to think the result should be
`{a: {:aa 1 :cc 1}}`
bBut it is actually: `{a: {:cc 1}}`. 

The `:a` value in `map2`, which is `{:cc 1}`, simply replaces **completely** the earlier value of `{:aa 1}`. The values `{:aa 1}` and `{:cc 1} are not themselves merged because `merge` is shallow and does not act deeply/recusively on the map values themselves.

== Beyond Default `merge` Behaviour

Often, this default `merge` behaviour is often good enough, particularly when combining profiles with disjoint keys. 

But, sometimes, when profiles have overlapping keys it is useful to take control about how the `values` 
are combined. 

This library lets you take change of the combining process for each potential key in XXX more here.

[source, Clojure]
----
(reg-event-fx
   :register-my-http-profile
   (fn [_ _]
      {:http   {:http/reg-profile   :xyz
      
                ;; the values we are capturing and associating with this profile 
                :http/values {   
                              ;; compose the FSM
                              :http/in-process    [:my-processor]
                              :http/in-problem    [:generic-problem :extra "whatever"]
                              :http/in-failed     [:my-special-failed]
                              :http/in-cancelled  [:generic-cancelled]
                              :http/in-done       [:generic-done]
                              
                              :http/timeout       3000
                              
                              :http/context  {:max-retries 2}}}}))               
                
                ;; Optional, advanced feature.
                ;; Profiles themselves can be combined/composed.
                ;; In this section, you can specify how the `:http/values` in this 
                ;; profile should be combined with the values in other profile. 
                ;; For each key in `:http/values` provide you can provide a two argument 
                ;; function to do the combining. 
                ;; The two arguments given to this function will be:
                ;;    (1) the value in "other" profile 
                ;;    (2) the value in this profile
                ;; 
                ;; Example combining functions:
                ;;    - `merge` would be useful if combining maps
                ;;    - `conj` would be useful for combining vectors
                ;;    - `str` would be useful for combining strings (URI?)
                ;;    - `#(identity %2)` would cause the value in this profile
                ;;      overwrite the value in the other profile. 
                ;; 
                :http/combine   {:http/params   merge
                                 :http/get      str }}}))
----

== About State

Let's talk about the two kinds of State:

* `request-state` is detail about a request, maintained by this library 
   to get its job done. It represents the "working memory" of the FSM and it 
   exists only for the lifetime 
   of the request. It includes such data as an id, the currently logical
   state of the FSM, the original request, current number of retries, a trace history through
   the FSM including timings, etc. 

   XXX where is this state? It is all data. In `app-db` at a library-specific path? or, outside of `app-db`
   in an atom held by the library? , deep within the library, 

* `app-state` - this is the application state which represents the request (and not the library's state). 
  It is typically a map which exists at a particular path within `app-db` but the contents of this 
  map is up to you, the writer of the application. Speaking generally, we can say that it will be 
  "a materialised view" of the full `request-state` and that this view is created and then maintained by the 
  *_Logical State Handlers_* you write.
  
Typically,
  the `in-setup` handler initialises this map, and it is 
  then updated across the request handling process by the various FSM handlers. 
  ine" (FSM). and will be sufficient to render a UI for the user. 
  This state outlasts the request - particularly the most important part, the processed response to 
  the request.  


An example of `app-state` map. 
[source, Clojure]
----
{
  :request-id  123456
  :loading?    true
  :error?      nil or "Something bad happened"
  :result      nil
  :retries     0
  :cancelled?  false
  :description "Loading filtered thingos"
}
----

This is the data in `app-db` which the view functions might subscribe to, in order to render the UI

XXX consider what else needs to happen to help `re-frame-async-flow`

So, I'd like to stress two points already made:
   - lifetime: `app-state` exists for as long as your applciation code says it should - it persists. Whereas 
     `request-state` is created and destroyed by this library - it is a means to an ends - it is transatory. 
   - during the request process, `request-state` tends to be authorative. : `app-state` is something 
     of a projection or materialised view of `request-state`. (Not entirely true but a useful mental model at
     this early stage in explanation)

While `app-state` ....  there might need to be a `:loading?` value      set to true to indicate that the busy twirly should be kept up.  Or perhaps a `:retrying?` flag might need to be "projected" from the    `reguest-state` so that, again, the UI can show the user what is happening.  

Ultimately, the most important part of this `app-state` is the (processed) response data itself. But there will be other information alongside it. For this reason, `presentation-state` is normally a map of values with a key for `response`, but it has other values.

The `presentation-state` (a map) is put at the path nominated within `app-db`.

The `app-state` is managed by your `Logical State Handlers`. You control what data is projected from the `request-state` across into the `presentation-state`. Because you, the application programmer, knows what you want to set within `app-db`. You know how you want the UI to render the state of the request process.

For example:
  - it is the job of the `in-setup` to initially create the  `XXX-state` assumed to be a map. 
    And it might initially establish within this map a `:loading?` flag as `true`. 
  - it is then the job of the `in-teardown` handler to set the `:loading?` flag back to `false`
    (thus taking down the twirly). 
    
    
== Recipies 


Receipies for each of the Logical State Handlers ... 

in-setup:

* establish the app-state at the nominated path 
* optionally, obtain the id of the request, to store in app-state to allow for, later, user cancellation 
* optionally, put up a twirly-busy-thing, perhaps with a description pf the request: "Loading all the blah things", perhaps with a cancel button 
* trigger `send`

in-waiting:

* you don't write this. Provided by this library. 
* wait for an HTTP reponse 
* process the response to determine what's happened. 
* be careful when doing the initial processing, because, for example, the JSON might have been corrupted. You might get a 200 response but not be able to read the JSON payload. 
* triggers either `timeout` or `success`, `unsuccessful`
  
in-processing:

* Process the response: turn tansit JSON into transit or 
* store in app
* trigger `processed`

in-succeeded:

* 
* trigger `XXX`
  
in-problem:

* decide what to do about the problem - retry or give up? 
* trigger `fail` or `retry`

in-failed:

* log the error
* show the error to the user
* 
* put the applicatio back into a sane state
* trigger `done`
  
in-cancelled:

* put the application into a state consistent with the cancellation. What does the user see? What can they do next. 
* update `app-state`, maybe. 
* trigger `done`
  
in-teardown:

* take down the twirly 
* change `:loading?` to false. 
* trigger `destroy`
  


   



